<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>–°–ø–µ–∫—Ç—Ä –≥–æ–ª–æ—Å–∞ ‚Äî –æ–Ω–ª–∞–π–Ω –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä (F1‚ÄìF4)</title>
<style>
  :root {
    --bg: #ffffff;
    --fg: #111111;
    --muted: #666666;
    --accent: #000000;
    --grid: #bbbbbb;
  }
  html, body { height: 100%; }
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
    margin: 0; padding: 16px; background: var(--bg); color: var(--fg);
  }
  h1 { font-size: 20px; margin: 0 0 8px 0; }
  .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
  .panel {
    border: 1px solid #ddd; border-radius: 12px; padding: 12px; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    margin-bottom: 12px;
  }
  label { font-size: 14px; color: var(--muted); margin-right: 6px; }
  button, select, input[type="range"], input[type="number"] {
    font: inherit; border-radius: 10px; border: 1px solid #ccc; padding: 6px 10px; background: #fafafa; color: var(--fg);
  }
  button { background: #111; color: #fff; cursor: pointer; }
  button.secondary { background: #f5f5f5; color: #111; }
  button:disabled { opacity: .5; cursor: not-allowed; }
  canvas { width: 100%; height: 360px; display: block; background: #fff; border-radius: 12px; }
  .foot { font-size: 12px; color: var(--muted); margin-top: 6px; }
  .badge { padding: 2px 8px; border-radius: 999px; border: 1px solid #ddd; background: #f8f8f8; }
  .grid-note { font-size: 12px; color: var(--muted); }
  .flex { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .spacer { flex: 1; }
  .hr { height: 1px; background: #eee; margin: 10px 0; }
</style>
</head>
<body>
  <h1>–°–ø–µ–∫—Ç—Ä –≥–æ–ª–æ—Å–∞ ‚Äî –æ–Ω–ª–∞–π–Ω –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä (F1‚ÄìF4)</h1>
  <div class="panel">
    <div class="row">
      <button id="btnStart">‚ñ∂ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
      <button id="btnStop" class="secondary" disabled>‚ñ† –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
      <span id="status" class="badge">–°—Ç–∞—Ç—É—Å: –æ–∂–∏–¥–∞–Ω–∏–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞‚Ä¶</span>
      <span class="spacer"></span>
      <button id="btnFreeze" class="secondary" disabled>‚è∏Ô∏è –ó–∞–º–æ—Ä–æ–∑–∏—Ç—å/–≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å</button>
      <button id="btnSnapshot" class="secondary" disabled>üì∏ –°–Ω–∏–º–æ–∫ PNG</button>
      <button id="btnSnapshotHTML" class="secondary" disabled>üìÑ –°–Ω–∏–º–æ–∫ HTML</button>
      <button id="btnXLSX" class="secondary" disabled>‚¨á –≠–∫—Å–ø–æ—Ä—Ç XLSX</button>
    </div>
    <div class="hr"></div>
    <div class="flex">
      <label for="selFFT">FFT —Ä–∞–∑–º–µ—Ä:</label>
      <select id="selFFT">
        <option>2048</option>
        <option selected>4096</option>
        <option>8192</option>
        <option>16384</option>
      </select>

      <label for="rngSmooth">–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ:</label>
      <input id="rngSmooth" type="range" min="0" max="0.95" step="0.05" value="0.6">
      <span id="lblSmooth" class="badge">0.60</span>

      <label for="maxHz">–ú–∞–∫—Å. —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü):</label>
      <input id="maxHz" type="number" min="1000" max="22050" step="100" value="4000" style="width:100px;">

      <label for="peakThresh">–ü–æ—Ä–æ–≥ –ø–∏–∫–æ–≤ (–¥–ë):</label>
      <input id="peakThresh" type="number" step="1" value="-70" style="width:80px;">
      
      <label for="peakMinSep">–ú–∏–Ω. —Ä–∞–∑–Ω–æ—Å (–ì—Ü):</label>
      <input id="peakMinSep" type="number" step="10" value="150" style="width:80px;">

      <label><input id="chkFormants" type="checkbox" checked> –ü–æ–¥–ø–∏—Å–∏ F1‚ÄìF4</label>
      <label><input id="chkFormantLines" type="checkbox" checked> –ì—Ä–∞–Ω–∏—Ü—ã F1‚ÄìF4 (—à—Ç—Ä–∏—Ö–æ–≤—ã–µ)</label>
    </div>
    <div class="grid-note">–û—Å–∏: –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å ‚Äî —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü), –≤–µ—Ä—Ç–∏–∫–∞–ª—å ‚Äî —É—Ä–æ–≤–µ–Ω—å (–¥–ë). –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ —Å–µ—Ç–∫–∏ –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞—é—Ç—Å—è –ø–æ–¥ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø—Ä–µ–¥–µ–ª —á–∞—Å—Ç–æ—Ç—ã.</div>
  </div>

  <div class="panel">
    <canvas id="canvas" width="1200" height="400"></canvas>
    <div class="foot" id="footText">‚Äî</div>
  </div>

<script>
(() => {
  // State
  let audioCtx = null;
  let analyser = null;
  let micStream = null;
  let rafId = null;
  let frozen = false;
  let sampleRate = 48000; // will be replaced by real audioCtx.sampleRate
  let freqData = null; // Float32Array in dB
  let running = false;

  // UI
  const $ = sel => document.querySelector(sel);
  const btnStart = $("#btnStart");
  const btnStop = $("#btnStop");
  const btnFreeze = $("#btnFreeze");
  const btnSnapshot = $("#btnSnapshot");
  const btnSnapshotHTML = $("#btnSnapshotHTML");
  const btnXLSX = $("#btnXLSX");
  const status = $("#status");
  const canvas = $("#canvas");
  const ctx = canvas.getContext("2d");
  const selFFT = $("#selFFT");
  const rngSmooth = $("#rngSmooth");
  const lblSmooth = $("#lblSmooth");
  const maxHzInput = $("#maxHz");
  const peakThreshInput = $("#peakThresh");
  const peakMinSepInput = $("#peakMinSep");
  const chkFormants = $("#chkFormants");
  const chkFormantLines = $("#chkFormantLines");
  const footText = $("#footText");

  // ---- Persistence ----
  const STORAGE_KEY = "voice_spectrum_settings_v2"; // includes formant lines toggle
  function saveSettings() {
    const s = {
      fft: selFFT.value,
      smooth: rngSmooth.value,
      maxHz: maxHzInput.value,
      peakThresh: peakThreshInput.value,
      peakMinSep: peakMinSepInput.value,
      showFormants: chkFormants.checked ? 1 : 0,
      showFormantLines: chkFormantLines.checked ? 1 : 0,
    };
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); } catch (e) {}
  }
  function loadSettings() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const s = JSON.parse(raw);
      if (s.fft != null) selFFT.value = String(s.fft);
      if (s.smooth != null) { rngSmooth.value = String(s.smooth); lblSmooth.textContent = (+s.smooth).toFixed(2); }
      if (s.maxHz != null) maxHzInput.value = String(s.maxHz);
      if (s.peakThresh != null) peakThreshInput.value = String(s.peakThresh);
      if (s.peakMinSep != null) peakMinSepInput.value = String(s.peakMinSep);
      if (s.showFormants != null) chkFormants.checked = !!(+s.showFormants);
      if (s.showFormantLines != null) chkFormantLines.checked = !!(+s.showFormantLines);
    } catch (e) {}
  }

  function setStatus(text) {
    status.textContent = "–°—Ç–∞—Ç—É—Å: " + text;
  }

  function tzOffsetString(d) {
    const off = -d.getTimezoneOffset(); // minutes east of UTC
    const sign = off >= 0 ? "+" : "-";
    const abs = Math.abs(off);
    const hh = String(Math.floor(abs/60)).padStart(2,"0");
    const mm = String(abs%60).padStart(2,"0");
    return `${sign}${hh}:${mm}`;
  }
  function tsNow() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    return `${yyyy}-${mm}-${dd} ${hh}:${mi}:${ss} (UTC${tzOffsetString(d)})`;
  }

  function hzPerBin() {
    return sampleRate / analyser.fftSize;
  }

  function binForHz(hz) {
    return Math.min(analyser.frequencyBinCount - 1, Math.max(0, Math.round(hz / hzPerBin())));
  }

  function formatHz(v) {
    return Math.round(v).toString();
  }
  function formatDb(v) {
    return (Math.round(v * 10) / 10).toFixed(1);
  }

  // ---- Nice ticks for vertical grid ----
  function niceStep(max, target = 8) {
    if (max <= 0 || !isFinite(max)) return 1;
    const raw = max / Math.max(1, target);
    const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
    const norm = raw / pow10;
    let mult = 1;
    if (norm <= 1) mult = 1;
    else if (norm <= 2) mult = 2;
    else if (norm <= 2.5) mult = 2.5;
    else if (norm <= 5) mult = 5;
    else mult = 10;
    return mult * pow10;
  }
  function generateTicks(max, target=8) {
    const step = niceStep(max, target);
    const ticks = [];
    for (let v = 0; v <= max + 1e-9; v += step) ticks.push(Math.round(v));
    // Ensure last tick is exactly max if it's close
    if (Math.abs(ticks[ticks.length-1] - max) > step*0.4) ticks.push(Math.round(max));
    return {ticks, step};
  }

  async function start() {
    if (running) return;
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setStatus("–±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç getUserMedia (–Ω—É–∂–µ–Ω https/–ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä –∏ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –±—Ä–∞—É–∑–µ—Ä)");
        return;
      }
      setStatus("–∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç—Å—è –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É‚Ä¶");
      micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }, video: false });
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
      sampleRate = audioCtx.sampleRate;

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = parseInt(selFFT.value, 10);
      analyser.smoothingTimeConstant = parseFloat(rngSmooth.value);
      analyser.minDecibels = -120;
      analyser.maxDecibels = -10;

      const source = audioCtx.createMediaStreamSource(micStream);
      source.connect(analyser);

      freqData = new Float32Array(analyser.frequencyBinCount);
      running = true;
      frozen = false;

      btnStart.disabled = true;
      btnStop.disabled = false;
      btnFreeze.disabled = false;
      btnSnapshot.disabled = false;
      btnSnapshotHTML.disabled = false;
      btnXLSX.disabled = false;

      setStatus(`–∏–¥—ë—Ç –∞–Ω–∞–ª–∏–∑‚Ä¶ (–¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏—è ${sampleRate} –ì—Ü)`);
      drawLoop();
    } catch (err) {
      console.error(err);
      setStatus("–æ—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: " + (err.message || err));
    }
  }

  function stop() {
    running = false;
    frozen = false;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    if (audioCtx) {
      audioCtx.close();
      audioCtx = null;
    }
    btnStart.disabled = false;
    btnStop.disabled = true;
    btnFreeze.disabled = true;
    btnSnapshot.disabled = true;
    btnSnapshotHTML.disabled = true;
    btnXLSX.disabled = true;
    setStatus("–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
  }

  function toggleFreeze() {
    frozen = !frozen;
    btnFreeze.textContent = frozen ? "‚ñ∂ –í–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å" : "‚è∏Ô∏è –ó–∞–º–æ—Ä–æ–∑–∏—Ç—å/–≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å";
  }

  function updateFFT() {
    if (analyser) {
      analyser.fftSize = parseInt(selFFT.value, 10);
      freqData = new Float32Array(analyser.frequencyBinCount);
    }
    saveSettings();
  }

  function updateSmooth() {
    const v = parseFloat(rngSmooth.value);
    if (analyser) analyser.smoothingTimeConstant = v;
    lblSmooth.textContent = v.toFixed(2);
    saveSettings();
  }

  // Listeners
  selFFT.addEventListener("change", updateFFT);
  rngSmooth.addEventListener("input", updateSmooth);
  maxHzInput.addEventListener("change", () => { saveSettings(); });
  peakThreshInput.addEventListener("change", saveSettings);
  peakMinSepInput.addEventListener("change", saveSettings);
  chkFormants.addEventListener("change", saveSettings);
  chkFormantLines.addEventListener("change", saveSettings);

  btnStart.addEventListener("click", start);
  btnStop.addEventListener("click", stop);
  btnFreeze.addEventListener("click", toggleFreeze);
  btnSnapshot.addEventListener("click", snapshotPNG);
  btnSnapshotHTML.addEventListener("click", snapshotHTML);
  btnXLSX.addEventListener("click", exportXLSX);

  function drawGrid(x0, y0, w, h, maxHz) {
    ctx.save();
    ctx.strokeStyle = "#bbbbbb";
    ctx.lineWidth = 1;

    // Vertical grid using nice ticks
    const {ticks} = generateTicks(maxHz, 8);
    ticks.forEach((f) => {
      const x = x0 + (f / maxHz) * w;
      ctx.beginPath();
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y0 + h);
      ctx.stroke();

      // label
      ctx.fillStyle = "#444";
      ctx.font = "12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(String(f), x, y0 + h + 16);
    });

    // Horizontal grid: -110 .. -10 dB (10 dB step)
    const minDb = -110, maxDb = -10, stepDb = 10;
    for (let d = minDb; d <= maxDb; d += stepDb) {
      const y = y0 + h - ((d - minDb) / (maxDb - minDb)) * h;
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(x0 + w, y);
      ctx.stroke();

      // label
      ctx.fillStyle = "#444";
      ctx.textAlign = "right";
      ctx.fillText(d.toString(), x0 - 6, y + 4);
    }

    // Axes
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 1.5;
    // X axis
    ctx.beginPath();
    ctx.moveTo(x0, y0 + h);
    ctx.lineTo(x0 + w, y0 + h);
    ctx.stroke();
    // Y axis
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0, y0 + h);
    ctx.stroke();

    // Titles
    ctx.fillStyle = "#111";
    ctx.textAlign = "left";
    ctx.fillText("–ß–∞—Å—Ç–æ—Ç–∞, –ì—Ü", x0 + 8, y0 + h + 32);
    ctx.save();
    ctx.translate(x0 - 32, y0 + 16);
    ctx.rotate(-Math.PI/2);
    ctx.fillText("–£—Ä–æ–≤–µ–Ω—å, –¥–ë", 0, 0);
    ctx.restore();

    ctx.restore();
  }

  function detectFormants(peaks, minSepHz) {
    const chosen = [];
    for (const p of peaks) {
      if (chosen.length >= 4) break;
      let ok = true;
      for (const c of chosen) {
        if (Math.abs(c.hz - p.hz) < minSepHz) { ok = false; break; }
      }
      if (ok) chosen.push(p);
    }
    chosen.sort((a,b) => a.hz - b.hz);
    return chosen;
  }

  function pickPeaks(dbArray, maxHz, threshDb) {
    const maxBin = binForHz(maxHz);
    const peaks = [];
    for (let i = 2; i < maxBin - 2; i++) {
      const v = dbArray[i];
      if (v < threshDb) continue;
      if (v > dbArray[i-1] && v > dbArray[i+1] && v > dbArray[i-2] && v > dbArray[i+2]) {
        peaks.push({ i, db: v, hz: i * hzPerBin() });
      }
    }
    peaks.sort((a,b) => b.db - a.db);
    return peaks;
  }

  function drawLoop() {
    if (!running) return;
    if (!frozen) {
      analyser.getFloatFrequencyData(freqData);
    }
    render();
    rafId = requestAnimationFrame(drawLoop);
  }

  function render() {
    const W = canvas.width;
    const H = canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,W,H);

    // Plot area
    const margin = { left: 56, right: 16, top: 20, bottom: 46 };
    const x0 = margin.left, y0 = margin.top;
    const w = W - margin.left - margin.right;
    const h = H - margin.top - margin.bottom;

    const maxHz = Math.max(1000, Math.min(parseInt(maxHzInput.value || "4000", 10), Math.floor(sampleRate/2)));
    drawGrid(x0, y0, w, h, maxHz);

    if (!freqData) return;

    // Draw spectrum
    ctx.save();
    ctx.beginPath();
    ctx.rect(x0, y0, w, h);
    ctx.clip();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#000000";
    const minDb = -110, maxDb = -10;
    const maxBin = binForHz(maxHz);
    for (let i = 0; i < maxBin; i++) {
      const f = i * hzPerBin();
      const x = x0 + (f / maxHz) * w;
      const v = freqData[i];
      const y = y0 + h - ((v - minDb) / (maxDb - minDb)) * h;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();

    // Peaks / Formants
    const threshDb = parseFloat(peakThreshInput.value || "-70");
    const minSepHz = parseFloat(peakMinSepInput.value || "150");
    const peaks = pickPeaks(freqData, maxHz, threshDb);
    const chosen = detectFormants(peaks, minSepHz);

    // Optional vertical dashed lines at F1..F4
    if (chkFormantLines.checked && chosen.length) {
      ctx.save();
      ctx.setLineDash([6, 4]);
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 1;
      chosen.forEach(p => {
        const x = x0 + (p.hz / maxHz) * w;
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y0 + h);
        ctx.stroke();
      });
      ctx.restore();
    }

    // Draw selected peaks (markers + labels)
    ctx.save();
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "center";
    const labels = ["F1", "F2", "F3", "F4"];
    chosen.forEach((p, idx) => {
      const x = x0 + (p.hz / maxHz) * w;
      const y = y0 + h - ((p.db - (-110)) / (100)) * h;
      // Tick
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y0 + h);
      ctx.lineTo(x, y0 + h - 8);
      ctx.stroke();
      // Marker
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI*2);
      ctx.stroke();
      // Label
      if (chkFormants.checked) {
        const tag = labels[idx] || ("P" + (idx+1));
        const text = `${tag} ‚âà ${formatHz(p.hz)} –ì—Ü (${formatDb(p.db)} –¥–ë)`;
        ctx.fillStyle = "#111";
        ctx.fillText(text, x, y - 8 - 10*idx);
      }
    });
    ctx.restore();

    // Footer text with timestamp
    const stamp = tsNow();
    if (chosen.length) {
      const s = chosen.map((p, i) => `${["F1","F2","F3","F4"][i] || ("P"+(i+1))}: ${formatHz(p.hz)} –ì—Ü`).join(" | ");
      footText.textContent = `${stamp} ‚Äî –§–æ—Ä–º–∞–Ω—Ç–Ω—ã–µ –ø–∏–∫–∏: ${s}.  –ü–æ—Ä–æ–≥: ${threshDb} –¥–ë, –ú–∏–Ω. —Ä–∞–∑–Ω–æ—Å: ${minSepHz} –ì—Ü, FFT: ${analyser.fftSize}, f_s: ${sampleRate} –ì—Ü.`;
    } else {
      footText.textContent = `${stamp} ‚Äî –ü–∏–∫–∏ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã (—É–≤–µ–ª–∏—á—å—Ç–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å, —É–º–µ–Ω—å—à–∏—Ç–µ –ø–æ—Ä–æ–≥ –∏–ª–∏ –¥–∏–∞–ø–∞–∑–æ–Ω —á–∞—Å—Ç–æ—Ç). FFT: ${analyser.fftSize}, f_s: ${sampleRate} –ì—Ü.`;
    }
  }

  function buildComposedCanvasWithFooter() {
    const dpr = window.devicePixelRatio || 1;
    const srcW = canvas.width;
    const srcH = canvas.height;
    const footerH = Math.round(36 * dpr);
    const out = document.createElement("canvas");
    out.width = srcW;
    out.height = srcH + footerH;
    const octx = out.getContext("2d");
    octx.fillStyle = "#ffffff";
    octx.fillRect(0,0,out.width,out.height);
    octx.drawImage(canvas, 0, 0);
    octx.fillStyle = "#111111";
    octx.font = `${Math.round(12 * dpr)}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
    octx.textBaseline = "middle";
    const text = (document.getElementById("footText")?.textContent || "").trim();
    const leftPad = Math.round(10 * dpr);
    const y = srcH + Math.round(footerH/2);
    const maxWidth = out.width - leftPad*2;
    const words = text.split(" ");
    const lines = [];
    let current = "";
    for (let i = 0; i < words.length; i++) {
      const trial = current ? (current + " " + words[i]) : words[i];
      if (octx.measureText(trial).width <= maxWidth) {
        current = trial;
      } else {
        if (current) lines.push(current);
        current = words[i];
      }
    }
    if (current) lines.push(current);
    const lineH = Math.round(16 * dpr);
    const startY = y - Math.round(((lines.length-1) * lineH)/2);
    lines.forEach((ln, k) => {
      octx.fillText(ln, leftPad, startY + k*lineH);
    });
    return out;
  }

  function snapshotPNG() {
    const out = buildComposedCanvasWithFooter();
    const link = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    link.download = `voice_spectrum_${ts}.png`;
    link.href = out.toDataURL("image/png");
    link.click();
  }

  function snapshotHTML() {
    const out = buildComposedCanvasWithFooter();
    const imgData = out.toDataURL("image/png");
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const fftVal = analyser ? analyser.fftSize : (parseInt(selFFT.value,10)||4096);
    const smoothVal = parseFloat(rngSmooth.value || "0").toFixed(2);
    const maxHzVal = parseInt(maxHzInput.value || "4000", 10);
    const threshVal = parseFloat(peakThreshInput.value || "-70");
    const sepVal = parseFloat(peakMinSepInput.value || "150");
    const formantsOn = !!chkFormants.checked;
    const linesOn = !!chkFormantLines.checked;

    const doc = [
      "<!DOCTYPE html>",
      "<html lang=\"ru\">",
      "<head>",
      "<meta charset=\"UTF-8\" />",
      "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />",
      "<title>–°–Ω–∏–º–æ–∫ —Å–ø–µ–∫—Ç—Ä–∞ –≥–æ–ª–æ—Å–∞</title>",
      "<style>",
      "body{font-family:system-ui,-apple-system,'Segoe UI',Roboto,Arial,'Noto Sans','Helvetica Neue',sans-serif;margin:0;padding:16px;background:#fff;color:#111}",
      "img{max-width:100%;height:auto;border:1px solid #ddd;border-radius:12px;}",
      "h1{font-size:20px;margin:0 0 8px 0;}",
      "code,pre{background:#f7f7f7;border:1px solid #eee;border-radius:8px;padding:8px 10px;display:block;white-space:pre-wrap;}",
      ".meta{font-size:14px;color:#333;margin:8px 0;}",
      "</style>",
      "</head>",
      "<body>",
      "<h1>–°–Ω–∏–º–æ–∫ —Å–ø–µ–∫—Ç—Ä–∞ –≥–æ–ª–æ—Å–∞</h1>",
      "<img alt=\"–°–Ω–∏–º–æ–∫ —Å–ø–µ–∫—Ç—Ä–∞\" src=\"", imgData, "\" />",
      "<h2 style=\"font-size:16px;margin-top:16px;\">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã</h2>",
      "<pre>",
      "FFT: ", String(fftVal), "\n",
      "–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ: ", String(smoothVal), "\n",
      "–ú–∞–∫—Å. —á–∞—Å—Ç–æ—Ç–∞: ", String(maxHzVal), " –ì—Ü\n",
      "–ü–æ—Ä–æ–≥ –ø–∏–∫–æ–≤: ", String(threshVal), " –¥–ë\n",
      "–ú–∏–Ω. —Ä–∞–∑–Ω–æ—Å –ø–∏–∫–æ–≤: ", String(sepVal), " –ì—Ü\n",
      "–ü–æ–¥–ø–∏—Å–∏ —Ñ–æ—Ä–º–∞–Ω—Ç–æ–≤: ", (formantsOn ? "–≤–∫–ª—é—á–µ–Ω—ã" : "–≤—ã–∫–ª—é—á–µ–Ω—ã"), "\n",
      "–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã: ", (linesOn ? "–≤–∫–ª—é—á–µ–Ω—ã (—à—Ç—Ä–∏—Ö–æ–≤—ã–µ)" : "–≤—ã–∫–ª—é—á–µ–Ω—ã"), "\n",
      "</pre>",
      "<div class=\"meta\">–ò—Å—Ç–æ—á–Ω–∏–∫: –ª–æ–∫–∞–ª—å–Ω–∞—è –∑–∞–ø–∏—Å—å —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞; —Ñ–∞–π–ª —Å–∞–º–æ–¥–æ—Å—Ç–∞—Ç–æ—á–µ–Ω, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω ", new Date().toLocaleString(), ".</div>",
      "</body>",
      "</html>"
    ].join("");

    const blob = new Blob([doc], {type: "text/html"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `voice_spectrum_snapshot_${ts}.html`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  // ---------- XLSX export (no external libs) ----------
  function crc32(buf) {
    let c = ~0;
    for (let i = 0; i < buf.length; i++) {
      c ^= buf[i];
      for (let k = 0; k < 8; k++) {
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
    }
    return ~c >>> 0;
  }
  function dosDateTime(d=new Date()) {
    const time = (d.getHours() << 11) | (d.getMinutes() << 5) | ((d.getSeconds()/2) & 0x1F);
    const date = (((d.getFullYear()-1980) & 0x7F) << 9) | ((d.getMonth()+1) << 5) | (d.getDate());
    return {time, date};
  }
  function le16(n) { const b = new Uint8Array(2); const v = new DataView(b.buffer); v.setUint16(0, n, true); return b; }
  function le32(n) { const b = new Uint8Array(4); const v = new DataView(b.buffer); v.setUint32(0, n, true); return b; }
  function concatUint8(chunks) { let len = 0; chunks.forEach(c => len += c.length); const out = new Uint8Array(len); let off = 0; chunks.forEach(c => { out.set(c, off); off += c.length; }); return out; }
  function strBytes(s) { return new TextEncoder().encode(s); }
  function xmlEscape(s) { return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }

  function makeZip(files) {
    const now = dosDateTime(new Date());
    const localChunks = []; const centralChunks = []; let offset = 0;
    files.forEach(file => {
      const nameBytes = strBytes(file.name);
      const data = file.bytes;
      const crc = crc32(data);
      const compMethod = 0;
      const compData = data;
      const lh = [
        strBytes("PK\x03\x04"),
        le16(20),
        le16(0),
        le16(compMethod),
        le16(now.time),
        le16(now.date),
        le32(crc),
        le32(compData.length),
        le32(data.length),
        le16(nameBytes.length),
        le16(0),
        nameBytes,
        compData
      ];
      const local = concatUint8(lh);
      localChunks.push(local);

      const ch = [
        strBytes("PK\x01\x02"),
        le16(0x031E),
        le16(20),
        le16(0), le16(compMethod),
        le16(now.time), le16(now.date),
        le32(crc), le32(compData.length), le32(data.length),
        le16(nameBytes.length), le16(0), le16(0),
        le16(0), le16(0), le32(0),
        le32(offset),
        nameBytes
      ];
      const central = concatUint8(ch);
      centralChunks.push(central);

      offset += local.length;
    });
    const cd = concatUint8(centralChunks);
    const eocd = concatUint8([
      strBytes("PK\x05\x06"),
      le16(0), le16(0),
      le16(files.length), le16(files.length),
      le32(cd.length),
      le32(offset),
      le16(0)
    ]);
    return new Blob([concatUint8([...localChunks, cd, eocd])], {type: "application/zip"});
  }

  function buildSheetXML(rows) {
    const colName = (n) => {
      let s = ""; n = Math.max(1,n);
      while (n > 0) { const m = (n - 1) % 26; s = String.fromCharCode(65 + m) + s; n = Math.floor((n - 1)/26); }
      return s;
    };
    let r = 1;
    let xml = ['<?xml version="1.0" encoding="UTF-8"?>','<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">','<sheetData>'];
    rows.forEach(row => {
      xml.push(`<row r="${r}">`);
      for (let c = 0; c < row.length; c++) {
        const v = row[c];
        const cellRef = colName(c+1) + r;
        if (typeof v === "number" && isFinite(v)) {
          xml.push(`<c r="${cellRef}"><v>${v}</v></c>`);
        } else {
          const s = xmlEscape(String(v));
          xml.push(`<c r="${cellRef}" t="inlineStr"><is><t>${s}</t></is></c>`);
        }
      }
      xml.push(`</row>`);
      r++;
    });
    xml.push('</sheetData></worksheet>');
    return xml.join("");
  }

  function exportXLSX() {
    if (!freqData || !analyser) return;
    const maxHz = Math.max(1000, Math.min(parseInt(maxHzInput.value || "4000", 10), Math.floor(sampleRate/2)));
    const maxBin = binForHz(maxHz);
    const rows = [["freq_hz", "level_db"]];
    for (let i = 0; i < maxBin; i++) {
      const hz = i * hzPerBin();
      const db = freqData[i];
      rows.push([+hz.toFixed(1), +db.toFixed(2)]);
    }

    const files = [];
    files.push({name: "[Content_Types].xml", bytes: strBytes(
      '<?xml version="1.0" encoding="UTF-8"?>' +
      '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">' +
      '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>' +
      '<Default Extension="xml" ContentType="application/xml"/>' +
      '<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>' +
      '<Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>' +
      '</Types>'
    )});
    files.push({name: "_rels/.rels", bytes: strBytes(
      '<?xml version="1.0" encoding="UTF-8"?>' +
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
      '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>' +
      '</Relationships>'
    )});
    files.push({name: "xl/workbook.xml", bytes: strBytes(
      '<?xml version="1.0" encoding="UTF-8"?>' +
      '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" ' +
      'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">' +
      '<sheets><sheet name="spectrum" sheetId="1" r:id="rId1"/></sheets>' +
      '</workbook>'
    )});
    files.push({name: "xl/_rels/workbook.xml.rels", bytes: strBytes(
      '<?xml version="1.0" encoding="UTF-8"?>' +
      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
      '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>' +
      '</Relationships>'
    )});
    const sheetXml = buildSheetXML(rows);
    files.push({name: "xl/worksheets/sheet1.xml", bytes: strBytes(sheetXml)});

    const zipBlob = makeZip(files);
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    const a = document.createElement("a");
    a.href = URL.createObjectURL(zipBlob);
    a.download = `voice_spectrum_${ts}.xlsx`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 2000);
  }

  // HiDPI fix
  function resizeCanvasToDisplaySize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const { width, height } = rect;
    if (canvas.width !== Math.round(width * dpr) || canvas.height !== Math.round(height * dpr)) {
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
    }
  }
  const resizeObserver = new ResizeObserver(() => { resizeCanvasToDisplaySize(); });
  resizeObserver.observe(canvas);

  // Initial
  loadSettings();
  lblSmooth.textContent = parseFloat(rngSmooth.value).toFixed(2);
  resizeCanvasToDisplaySize();
  setStatus("–≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É");
})();
</script>
</body>
</html>
