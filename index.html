<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>–°–ø–µ–∫—Ç—Ä –≥–æ–ª–æ—Å–∞ ‚Äî –æ–Ω–ª–∞–π–Ω –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä (F1‚ÄìF4)</title>
<style>
  :root {
    --bg: #ffffff;
    --fg: #111111;
    --muted: #666666;
    --accent: #000000;
    --good: #0a7d0a;
    --warn: #c77d00;
    --bad: #b00020;
    --grid: #bbbbbb;
  }
  html, body { height: 100%; }
  body {
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
    margin: 0; padding: 16px; background: var(--bg); color: var(--fg);
  }
  h1 { font-size: 20px; margin: 0 0 8px 0; }
  .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
  .panel {
    border: 1px solid #ddd; border-radius: 12px; padding: 12px; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    margin-bottom: 12px;
  }
  label { font-size: 14px; color: var(--muted); margin-right: 6px; }
  button, select, input[type="range"], input[type="number"] {
    font: inherit; border-radius: 10px; border: 1px solid #ccc; padding: 6px 10px; background: #fafafa; color: var(--fg);
  }
  button { background: #111; color: #fff; cursor: pointer; }
  button.secondary { background: #f5f5f5; color: #111; }
  button:disabled { opacity: .5; cursor: not-allowed; }
  canvas { width: 100%; height: 360px; display: block; background: #fff; border-radius: 12px; }
  .foot { font-size: 12px; color: var(--muted); margin-top: 6px; }
  .badge { padding: 2px 8px; border-radius: 999px; border: 1px solid #ddd; background: #f8f8f8; }
  .grid-note { font-size: 12px; color: var(--muted); }
  .flex { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .spacer { flex: 1; }
  .hr { height: 1px; background: #eee; margin: 10px 0; }
</style>
</head>
<body>
  <h1>–°–ø–µ–∫—Ç—Ä –≥–æ–ª–æ—Å–∞ ‚Äî –æ–Ω–ª–∞–π–Ω –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä (F1‚ÄìF4)</h1>
  <div class="panel">
    <div class="row">
      <button id="btnStart">‚ñ∂ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
      <button id="btnStop" class="secondary" disabled>‚ñ† –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
      <span id="status" class="badge">–°—Ç–∞—Ç—É—Å: –æ–∂–∏–¥–∞–Ω–∏–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞‚Ä¶</span>
      <span class="spacer"></span>
      <button id="btnFreeze" class="secondary" disabled>‚è∏Ô∏è –ó–∞–º–æ—Ä–æ–∑–∏—Ç—å/–≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å</button>
      <button id="btnSnapshot" class="secondary" disabled>üì∏ –°–Ω–∏–º–æ–∫ PNG</button>
      <button id="btnCSV" class="secondary" disabled>‚¨á –≠–∫—Å–ø–æ—Ä—Ç CSV</button>
    </div>
    <div class="hr"></div>
    <div class="flex">
      <label for="selFFT">FFT —Ä–∞–∑–º–µ—Ä:</label>
      <select id="selFFT">
        <option>2048</option>
        <option selected>4096</option>
        <option>8192</option>
        <option>16384</option>
      </select>

      <label for="rngSmooth">–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ:</label>
      <input id="rngSmooth" type="range" min="0" max="0.95" step="0.05" value="0.6">
      <span id="lblSmooth" class="badge">0.60</span>

      <label for="maxHz">–ú–∞–∫—Å. —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü):</label>
      <input id="maxHz" type="number" min="1000" max="22050" step="100" value="4000" style="width:100px;">

      <label for="peakThresh">–ü–æ—Ä–æ–≥ –ø–∏–∫–æ–≤ (–¥–ë):</label>
      <input id="peakThresh" type="number" step="1" value="-70" style="width:80px;">
      
      <label for="peakMinSep">–ú–∏–Ω. —Ä–∞–∑–Ω–æ—Å (–ì—Ü):</label>
      <input id="peakMinSep" type="number" step="10" value="150" style="width:80px;">

      <label><input id="chkFormants" type="checkbox" checked> –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å F1‚ÄìF4</label>
    </div>
    <div class="grid-note">–û—Å–∏: –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å ‚Äî —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü), –≤–µ—Ä—Ç–∏–∫–∞–ª—å ‚Äî —É—Ä–æ–≤–µ–Ω—å (–¥–ë). –§–æ–Ω ‚Äî –±–µ–ª—ã–π, –ª–∏–Ω–∏–∏ ‚Äî —á—ë—Ä–Ω—ã–µ, —Å–µ—Ç–∫–∞ ‚Äî —Å–µ—Ä–∞—è.</div>
  </div>

  <div class="panel">
    <canvas id="canvas" width="1200" height="400"></canvas>
    <div class="foot" id="footText">‚Äî</div>
  </div>

<script>
(() => {
  // State
  let audioCtx = null;
  let analyser = null;
  let micStream = null;
  let rafId = null;
  let frozen = false;
  let fftSize = 4096;
  let sampleRate = 48000; // will be replaced by real audioCtx.sampleRate
  let freqData = null; // Float32Array in dB
  let running = false;

  // UI
  const $ = sel => document.querySelector(sel);
  const btnStart = $("#btnStart");
  const btnStop = $("#btnStop");
  const btnFreeze = $("#btnFreeze");
  const btnSnapshot = $("#btnSnapshot");
  const btnCSV = $("#btnCSV");
  const status = $("#status");
  const canvas = $("#canvas");
  const ctx = canvas.getContext("2d");
  const selFFT = $("#selFFT");
  const rngSmooth = $("#rngSmooth");
  const lblSmooth = $("#lblSmooth");
  const maxHzInput = $("#maxHz");
  const peakThreshInput = $("#peakThresh");
  const peakMinSepInput = $("#peakMinSep");
  const chkFormants = $("#chkFormants");
  const footText = $("#footText");

  function setStatus(text) {
    status.textContent = "–°—Ç–∞—Ç—É—Å: " + text;
  }

  function hzPerBin() {
    return sampleRate / analyser.fftSize;
  }

  function binForHz(hz) {
    return Math.min(analyser.frequencyBinCount - 1, Math.max(0, Math.round(hz / hzPerBin())));
  }

  function formatHz(v) {
    return Math.round(v).toString();
  }
  function formatDb(v) {
    return (Math.round(v * 10) / 10).toFixed(1);
  }

  async function start() {
    if (running) return;
    try {
      setStatus("–∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç—Å—è –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É‚Ä¶");
      micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }, video: false });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sampleRate = audioCtx.sampleRate;

      analyser = audioCtx.createAnalyser();
      analyser.fftSize = parseInt(selFFT.value, 10);
      analyser.smoothingTimeConstant = parseFloat(rngSmooth.value);
      analyser.minDecibels = -120;
      analyser.maxDecibels = -10;

      const source = audioCtx.createMediaStreamSource(micStream);
      source.connect(analyser);

      freqData = new Float32Array(analyser.frequencyBinCount);
      running = true;
      frozen = false;

      btnStart.disabled = true;
      btnStop.disabled = false;
      btnFreeze.disabled = false;
      btnSnapshot.disabled = false;
      btnCSV.disabled = false;

      setStatus(`–∏–¥—ë—Ç –∞–Ω–∞–ª–∏–∑‚Ä¶ (–¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏—è ${sampleRate} –ì—Ü)`);
      drawLoop();
    } catch (err) {
      console.error(err);
      setStatus("–æ—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: " + (err.message || err));
    }
  }

  function stop() {
    running = false;
    frozen = false;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    if (audioCtx) {
      audioCtx.close();
      audioCtx = null;
    }
    btnStart.disabled = false;
    btnStop.disabled = true;
    btnFreeze.disabled = true;
    btnSnapshot.disabled = true;
    btnCSV.disabled = true;
    setStatus("–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
  }

  function toggleFreeze() {
    frozen = !frozen;
    btnFreeze.textContent = frozen ? "‚ñ∂ –í–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å" : "‚è∏Ô∏è –ó–∞–º–æ—Ä–æ–∑–∏—Ç—å/–≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å";
  }

  function updateFFT() {
    if (!analyser) return;
    analyser.fftSize = parseInt(selFFT.value, 10);
    freqData = new Float32Array(analyser.frequencyBinCount);
  }

  function updateSmooth() {
    if (!analyser) return;
    const v = parseFloat(rngSmooth.value);
    analyser.smoothingTimeConstant = v;
    lblSmooth.textContent = v.toFixed(2);
  }

  selFFT.addEventListener("change", () => updateFFT());
  rngSmooth.addEventListener("input", () => updateSmooth());
  maxHzInput.addEventListener("change", () => {/* live redraw */});
  peakThreshInput.addEventListener("change", () => {/* live redraw */});
  peakMinSepInput.addEventListener("change", () => {/* live redraw */});
  chkFormants.addEventListener("change", () => {/* live redraw */});

  btnStart.addEventListener("click", start);
  btnStop.addEventListener("click", stop);
  btnFreeze.addEventListener("click", toggleFreeze);
  btnSnapshot.addEventListener("click", snapshotPNG);
  btnCSV.addEventListener("click", exportCSV);

  function drawGrid(x0, y0, w, h, maxHz) {
    ctx.save();
    ctx.strokeStyle = "#bbbbbb";
    ctx.lineWidth = 1;

    // Vertical grid: 0, 500, 1000, ... up to maxHz
    const stepHz = 500;
    for (let f = 0; f <= maxHz; f += stepHz) {
      const x = x0 + (f / maxHz) * w;
      ctx.beginPath();
      ctx.moveTo(x, y0);
      ctx.lineTo(x, y0 + h);
      ctx.stroke();

      // label
      ctx.fillStyle = "#444";
      ctx.font = "12px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(f.toString(), x, y0 + h + 16);
    }

    // Horizontal grid: -100 .. 0 dB (10 dB step)
    const minDb = -110, maxDb = -10, stepDb = 10;
    for (let d = minDb; d <= maxDb; d += stepDb) {
      const y = y0 + h - ((d - minDb) / (maxDb - minDb)) * h;
      ctx.beginPath();
      ctx.moveTo(x0, y);
      ctx.lineTo(x0 + w, y);
      ctx.stroke();

      // label
      ctx.fillStyle = "#444";
      ctx.textAlign = "right";
      ctx.fillText(d.toString(), x0 - 6, y + 4);
    }

    // Axes
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 1.5;
    // X axis
    ctx.beginPath();
    ctx.moveTo(x0, y0 + h);
    ctx.lineTo(x0 + w, y0 + h);
    ctx.stroke();
    // Y axis
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0, y0 + h);
    ctx.stroke();

    // Titles
    ctx.fillStyle = "#111";
    ctx.textAlign = "left";
    ctx.fillText("–ß–∞—Å—Ç–æ—Ç–∞, –ì—Ü", x0 + 8, y0 + h + 32);
    ctx.save();
    ctx.translate(x0 - 32, y0 + 16);
    ctx.rotate(-Math.PI/2);
    ctx.fillText("–£—Ä–æ–≤–µ–Ω—å, –¥–ë", 0, 0);
    ctx.restore();

    ctx.restore();
  }

  function detectFormants(peaks, minSepHz) {
    // Choose up to 4 prominent peaks with minimal separation
    const chosen = [];
    for (const p of peaks) {
      if (chosen.length >= 4) break;
      let ok = true;
      for (const c of chosen) {
        if (Math.abs(c.hz - p.hz) < minSepHz) { ok = false; break; }
      }
      if (ok) chosen.push(p);
    }
    // Sort by frequency ascending (F1..F4)
    chosen.sort((a,b) => a.hz - b.hz);
    return chosen;
  }

  function pickPeaks(dbArray, maxHz, threshDb) {
    const n = dbArray.length;
    const maxBin = binForHz(maxHz);
    const peaks = [];
    // Simple local-maximum finder with neighborhood check
    for (let i = 2; i < maxBin - 2; i++) {
      const v = dbArray[i];
      if (v < threshDb) continue;
      if (v > dbArray[i-1] && v > dbArray[i+1] && v > dbArray[i-2] && v > dbArray[i+2]) {
        peaks.push({ i, db: v, hz: i * hzPerBin() });
      }
    }
    // Sort by amplitude descending
    peaks.sort((a,b) => b.db - a.db);
    return peaks;
  }

  function drawLoop() {
    if (!running) return;
    if (!frozen) {
      analyser.getFloatFrequencyData(freqData);
    }
    render();
    rafId = requestAnimationFrame(drawLoop);
  }

  function render() {
    const W = canvas.width;
    const H = canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,W,H);

    // Plot area
    const margin = { left: 56, right: 16, top: 20, bottom: 46 };
    const x0 = margin.left, y0 = margin.top;
    const w = W - margin.left - margin.right;
    const h = H - margin.top - margin.bottom;

    const maxHz = Math.max(1000, Math.min(parseInt(maxHzInput.value || "4000", 10), Math.floor(sampleRate/2)));
    drawGrid(x0, y0, w, h, maxHz);

    if (!freqData) return;

    // Draw spectrum
    ctx.save();
    ctx.beginPath();
    ctx.rect(x0, y0, w, h);
    ctx.clip();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#000000";
    const minDb = -110, maxDb = -10;
    const maxBin = binForHz(maxHz);
    for (let i = 0; i < maxBin; i++) {
      const f = i * hzPerBin();
      const x = x0 + (f / maxHz) * w;
      const v = freqData[i];
      const y = y0 + h - ((v - minDb) / (maxDb - minDb)) * h;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();

    // Peaks / Formants
    const threshDb = parseFloat(peakThreshInput.value || "-70");
    const minSepHz = parseFloat(peakMinSepInput.value || "150");
    const peaks = pickPeaks(freqData, maxHz, threshDb);
    const chosen = detectFormants(peaks, minSepHz);

    // Draw selected peaks
    ctx.save();
    ctx.font = "12px system-ui, sans-serif";
    ctx.textAlign = "center";
    const labels = ["F1", "F2", "F3", "F4"];
    chosen.forEach((p, idx) => {
      const x = x0 + (p.hz / maxHz) * w;
      const y = y0 + h - ((p.db - (-110)) / (100)) * h; // same mapping as above
      // Tick
      ctx.strokeStyle = "#000000";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y0 + h);
      ctx.lineTo(x, y0 + h - 8);
      ctx.stroke();
      // Marker
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI*2);
      ctx.stroke();
      // Label
      if (chkFormants.checked) {
        const tag = labels[idx] || ("P" + (idx+1));
        const text = `${tag} ‚âà ${formatHz(p.hz)} –ì—Ü (${formatDb(p.db)} –¥–ë)`;
        ctx.fillStyle = "#111";
        ctx.fillText(text, x, y - 8 - 10*idx);
      }
    });
    ctx.restore();

    // Footer text
    if (chosen.length) {
      const s = chosen.map((p, i) => `${["F1","F2","F3","F4"][i] || ("P"+(i+1))}: ${formatHz(p.hz)} –ì—Ü`).join(" | ");
      footText.textContent = `–§–æ—Ä–º–∞–Ω—Ç–Ω—ã–µ –ø–∏–∫–∏: ${s}.  –ü–æ—Ä–æ–≥: ${threshDb} –¥–ë, –ú–∏–Ω. —Ä–∞–∑–Ω–æ—Å: ${minSepHz} –ì—Ü, FFT: ${analyser.fftSize}, f_s: ${sampleRate} –ì—Ü.`;
    } else {
      footText.textContent = `–ü–∏–∫–∏ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã (—É–≤–µ–ª–∏—á—å—Ç–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å, —É–º–µ–Ω—å—à–∏—Ç–µ –ø–æ—Ä–æ–≥ –∏–ª–∏ –¥–∏–∞–ø–∞–∑–æ–Ω —á–∞—Å—Ç–æ—Ç). FFT: ${analyser.fftSize}, f_s: ${sampleRate} –ì—Ü.`;
    }
  }

  function snapshotPNG() {
    const link = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    link.download = `voice_spectrum_${ts}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
  }

  function exportCSV() {
    if (!freqData || !analyser) return;
    const maxHz = Math.max(1000, Math.min(parseInt(maxHzInput.value || "4000", 10), Math.floor(sampleRate/2)));
    const maxBin = binForHz(maxHz);
    let csv = "freq_hz,level_db\n";
    for (let i = 0; i < maxBin; i++) {
      const hz = i * hzPerBin();
      const db = freqData[i];
      csv += `${hz.toFixed(1)},${db.toFixed(2)}\n`;
    }
    const blob = new Blob([csv], {type: "text/csv"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    a.href = url;
    a.download = `voice_spectrum_${ts}.csv`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  // HiDPI fix
  function resizeCanvasToDisplaySize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const { width, height } = rect;
    if (canvas.width !== Math.round(width * dpr) || canvas.height !== Math.round(height * dpr)) {
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
    }
  }
  const resizeObserver = new ResizeObserver(() => {
    resizeCanvasToDisplaySize();
  });
  resizeObserver.observe(canvas);

  // Initial
  resizeCanvasToDisplaySize();
  setStatus("–≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É");
})();
</script>
</body>
</html>
